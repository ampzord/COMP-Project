/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. PatternParser.jj */
/*@egen*/options
{
  LOOKAHEAD= 1;
             
}
 
PARSER_BEGIN(PatternParser)

import java.io.FileInputStream;
import java.io.FileNotFoundException;
 
public class PatternParser/*@bgen(jjtree)*/implements PatternParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTPatternParserState jjtree = new JJTPatternParserState();

/*@egen*/
  public static void main(String [] args) throws ParseException,
  FileNotFoundException
  {
    if (args.length < 1)
    {
      System.out.println("Write the filename of the pattern file.");
      System.exit(1);
    }
    //System.out.println("Reading from the file " + args[0] + "...\n");
    PatternParser patParser = new PatternParser(new FileInputStream(args[0]));

    ASTStart root = PatternParser.Start();
    // root.dump("");
    String code = root.generateJava();
    System.out.println(code);
  }
}

PARSER_END(PatternParser)

SKIP :
{
  	" "
	| "\r"
	| "\t"
	| "\n"
}

TOKEN :
{
  	  < IF                : "if" >
  	| < PATTERN      	  : "Pattern" >
    | < WHILE             : "while" >
	| < PARENTHESIS_OPEN  : "(" >
	| < PARENTHESIS_CLOSE : ")" >
	| < BRACKETS_OPEN	  : "{" >
	| < BRACKETS_CLOSE    : "}" >
	| < ELSE              : "else" >
	| < SEMI_COLON        : ";" >
	| < NEGATION          : "!" >
	| < ASSIGN			  : "=" >
	| < EQUALS			  : "==" >
	| < NOT_EQUALS		  : "!=" >
	| < PLUS_EQUAL        : "+=" >
	| < MINUS_EQUAL       : "-=" >
	| < DIV_EQUAL         : "/=" >
	| < MULT_EQUAL        : "*=" >
	| < PLUS              : "+" >
    | < MINUS             : "-" >
    | < INCREMENT         : "++" >
    | < DECREMENT         : "--" >
    | < GREATER_EQUAL	  : ">=" >
    | < GREATER		      : ">" >
    | < LESSER_EQUAL      : "<=" >
    | < LESSER			  : "<" >
    | < REMAINDER         : "%" >
    | < COMMA             : "," >
	| < INTEGER           : (["0"-"9"])+ >
	| < IDENTIFIER        : ([ "a"-"z", "A"-"Z" ]) ([ "a"-"z", "A"-"Z", "0"-"9" ])* >
	| < VARIABLE          : ("@" <IDENTIFIER> )>
 }



ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	(Pattern())*
	< EOF >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Function(): {/*@bgen(jjtree) Function */
                   ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) Function */
  try {
/*@egen*/
  t = < IDENTIFIER >
  { jjtn000.jjtSetValue(t.image); }
  < PARENTHESIS_OPEN > [Expression()(< COMMA > Expression())*] < PARENTHESIS_CLOSE > < SEMI_COLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Pattern(): {/*@bgen(jjtree) Pattern */
                  ASTPattern jjtn000 = new ASTPattern(JJTPATTERN);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) Pattern */
        try {
/*@egen*/
  	< PATTERN > t=< IDENTIFIER > { jjtn000.jjtSetValue(t.image); }
  	Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UnaryAssignmentSpecial() : {/*@bgen(jjtree) UnaryAssignmentSpecial */
  ASTUnaryAssignmentSpecial jjtn000 = new ASTUnaryAssignmentSpecial(JJTUNARYASSIGNMENTSPECIAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryAssignmentSpecial */
        try {
/*@egen*/
	UnaryExpression() < SEMI_COLON >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Assignment() : {/*@bgen(jjtree) Assignment */
                     ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1,t2; }
{/*@bgen(jjtree) Assignment */
    try {
/*@egen*/
    (      t1 = < VARIABLE > | t1= < IDENTIFIER >
    )
    { jjtn000.setAssignee(t1.image); }
    (      t2=< ASSIGN > | t2=< MINUS_EQUAL > | t2=< PLUS_EQUAL > | t2=< MULT_EQUAL > | t2=< DIV_EQUAL >
    )
    { jjtn000.setOperator(t2.image); }
     Expression() < SEMI_COLON >/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement()       : { }
{
	  IfStatement() | WhileStatement() | LOOKAHEAD(Assignment()) Assignment() | LOOKAHEAD(Function())Function() |  UnaryAssignmentSpecial()
}

void IfStatement() : {/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) IfStatement */
        try {
/*@egen*/
	< IF > <PARENTHESIS_OPEN > Expression() < PARENTHESIS_CLOSE > Block()  [<ELSE > Block()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void WhileStatement() : {/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) WhileStatement */
    try {
/*@egen*/
    < WHILE > <PARENTHESIS_OPEN > Expression() < PARENTHESIS_CLOSE > Block()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression()      : { }
{
    LOOKAHEAD(BinaryExpression()) BinaryExpression() |  LOOKAHEAD(UnaryExpression()) UnaryExpression() | Operand()
}
 
void UnaryExpression() : {/*@bgen(jjtree) UnaryExpression */
  ASTUnaryExpression jjtn000 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } 
{/*@bgen(jjtree) UnaryExpression */
        try {
/*@egen*/							
	Operator() Operand() | Operand() Operator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
 
void BinaryExpression() : {/*@bgen(jjtree) BinaryExpression */
  ASTBinaryExpression jjtn000 = new ASTBinaryExpression(JJTBINARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BinaryExpression */
    try {
/*@egen*/
    Operand() Operator() Operand()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Block() : {/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Block */
        try {
/*@egen*/
	< BRACKETS_OPEN > (Statement())* < BRACKETS_CLOSE >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Operand(): {/*@bgen(jjtree) Operand */
                  ASTOperand jjtn000 = new ASTOperand(JJTOPERAND);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) Operand */
    try {
/*@egen*/
    (      t=< VARIABLE > | t=< IDENTIFIER > | t= < INTEGER >
    )/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/
      { jjtn000.jjtSetValue(t.image); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
 
void Operator(): {/*@bgen(jjtree) Operator */
                   ASTOperator jjtn000 = new ASTOperator(JJTOPERATOR);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Operator */
  try {
/*@egen*/
  (
   t= < PLUS > | t=< MINUS > | t=< NOT_EQUALS > | t=< EQUALS > | t =< REMAINDER > | t=< INCREMENT > | t=< DECREMENT > | t=< NEGATION >
   | t=< GREATER > |t=< GREATER_EQUAL > | t=<LESSER > | t=< LESSER_EQUAL > | t=< PLUS_EQUAL > | t=< MINUS_EQUAL > | t=< MULT_EQUAL > | t=< DIV_EQUAL >
  )/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/
      { jjtn000.jjtSetValue(t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
/*
void Operator_Unary(): { Token t; }
{
	(	  t = < INCREMENT > | t=< DECREMENT >
	)
	{ jjtThis.jjtSetValue(t.image); }
}

void Operator_Binary(): { Token t; }
{
	(
	  t = < INCREMENT > | t=< DECREMENT >
	)
	{ jjtThis.jjtSetValue(t.image); }
}

void Operator_Assignment(): { Token t2; }
{
	(
	t2=< ASSIGN > | t2=< MINUS_EQUAL > | t2=< PLUS_EQUAL > | t2=< MULT_EQUAL > | t2=< DIV_EQUAL >
	)
	{ jjtThis.jjtSetValue(t.image); }
}
*/